<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 并发编程基础</title>
    <url>/2018/11/11/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线程"><a class="markdownIt-Anchor" href="#线程">#</a> 线程</h2>
<p>现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个 Java 程序，操作系统就会创建一个 Java 进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（LightWeight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。<br>
一个 Java 程序从 main () 方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上 Java 程序天生就是多线程程序，因为执行 main () 方法的是一个名称为 main 的线程。</p>
<span id="more"></span>
<h2 id="多线程优点"><a class="markdownIt-Anchor" href="#多线程优点">#</a> 多线程优点</h2>
<ul>
<li>更好地利用处理器资源</li>
<li>加快响应时间</li>
<li>更好的编程模型</li>
</ul>
<h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized">#</a> synchronized</h2>
<p>synchronized 作为最开始学习 Java 就会接触到的关键字，他的使用方法有三种</p>
<ul>
<li>修饰成员方法，为当前对象加锁，进入同步方法前要获得当前对象的锁。</li>
<li>修饰静态方法，对当前类对象加锁，需要获取当前类对象的锁。</li>
<li>修饰代码块，指定加锁对象，对指定的对象加锁。</li>
</ul>
<h2 id="cas"><a class="markdownIt-Anchor" href="#cas">#</a> CAS</h2>
<p>CAS 全称 Compare And Set（或 Compare And Swap）,CAS 包含三个操作数：内存位置 (V)、原值 (A)、新值 (B)。简单来说 CAS 操作就是一个虚拟机实现的原子操作，这个原子操作的功能就是将旧值 (A) 替换为新值 (B)，如果旧值 (A) 未被改变，则替换成功，如果旧值 (A) 已经被改变则替换失败。</p>
<p>在 UnSafe 中我们可以找到 CAS 相关的方法。<br>
我们使用 <code>java.util.concurrent.atomic.AtomicInteger</code>  来做个例子，首先在多线程下 i++ 一般得不到我们要的值，因为他不是一个原子操作，而使用 AtomicInteger 的 incrementAndGet 则不会出错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看 UnSafe 的 getAndAddInt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以不停的进行 CAS 操作，直到成功。</p>
<h2 id="volatile"><a class="markdownIt-Anchor" href="#volatile">#</a> volatile</h2>
<p>volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的 “可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<h2 id="aqsabstractqueuedsynchronizer"><a class="markdownIt-Anchor" href="#aqsabstractqueuedsynchronizer">#</a> AQS（AbstractQueuedSynchronizer）</h2>
<p>AQS 可以说是并发包的基石了，JUC 包中工具基本都是建立在 AQS 上面的。<br>
首先来看看 AQS 中的成员变量（方便阅读，所以将注释也搬了过来，可以对比学习）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment"> * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment"> * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment"> * CANCELLED.</span></span><br><span class="line"><span class="comment"> * 同步队列 头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment"> * method enq to add new wait node.</span></span><br><span class="line"><span class="comment"> * 同步队列 队尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> * 同步状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占模式下当前锁的持有者（在父类AbstractOwnableSynchronizer中）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>
<ul>
<li>state： 非常关键的一个变量，他表示了当前锁的状态</li>
<li>tail： 同步队列的队尾</li>
<li>head：队头，其实不算队头，因为他已经占有了锁，head 后面的才是在队列中等待的</li>
</ul>
<p>阻塞队列的情况如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">     +------+ prev  +-----+ prev  +-----+</span><br><span class="line"><span class="built_in">head</span> |      | &lt;---- |     | &lt;---- |     |  <span class="built_in">tail</span></span><br><span class="line">     |      | ----&gt; |     | ----&gt; |     |</span><br><span class="line">     +------+ next  +-----+ next  +-----+</span><br></pre></td></tr></table></figure>
<p>再来看看内部静态类 Node，想要获取锁的线程被包装在 node 节点中，node 节点又组成了一个队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="comment">//------------标识锁类型-------------------------------------</span></span><br><span class="line">        <span class="comment">//共享锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="comment">//独占锁</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//-----------------------------------------------------------</span></span><br><span class="line">        <span class="comment">//-------------------------等待状态---------------------------</span></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn&#x27;t need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn&#x27;t need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//状态变量</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//当前节点的前驱</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev&#x27;s from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//下一个节点 后驱</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//当前线程 保存了想要获取锁的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//下一个等待者</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//是否是共享节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//当前节点的前一个节点</span></span><br><span class="line">        <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mode封装了锁类型 共享或者独占</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下以 <code>ReentrantLock</code>  为例说明 AQS 是如何运行的 。</p>
<h3 id="aqs-在-reentrantlock-中的应用"><a class="markdownIt-Anchor" href="#aqs-在-reentrantlock-中的应用">#</a> AQS 在 ReentrantLock 中的应用</h3>
<p>ReentrantLock 提供的构造方法有两个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，默认使用非公平锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果为true则为公平锁，否则为非公平锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="nonfairsync"><a class="markdownIt-Anchor" href="#nonfairsync">#</a> NonfairSync</h4>
<p>NonfairSync 类实现了非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁实现，继承Sync类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首先调用加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//CAS操作加锁，将state值修改为 1则表示加锁成功（插队）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//将持有锁的线程设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果CAS操作失败（插队失败），尝试以独占锁方式加锁，acquire方法会调用tryAcquire(int acquires)方法尝试加锁，acquire()方法定义在AbstractQueuedSynchronizer（AQS）中</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="aqs-中-acquire-方法"><a class="markdownIt-Anchor" href="#aqs-中-acquire-方法">#</a> AQS 中 acquire 方法</h4>
<p>在非公平锁的模式下，首先会使用 CAS 获取锁，如果获取锁失败，会调用 <code>acquire(int arg)</code>  方法，而在公平锁模式下，则直接调用了 <code>acquire(int arg)</code>  方法，来看看 acquire (int arg) 方法内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，调用tryAcquire方法 ，tryAcquire在FairSync和NonfairSync中被定义，如果尝试加锁失败（有其他线程抢占了锁就会加锁失败）</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    <span class="comment">//将线程添加到阻塞队列中 ，首先运行的是addWaiter（）方法，addWaiter()方法会将当前线程以独占模式的方式封装进Node节点中，并将该Node节点添加到队尾，然后返回该节点</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">//中断线程</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="nonfairsync-中-tryacquire-方法"><a class="markdownIt-Anchor" href="#nonfairsync-中-tryacquire-方法">#</a> NonfairSync 中 tryAcquire 方法</h4>
<p>acquire 先调用 tryAcquire 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试加锁 在ReentrantLock中，参数 acquires的值为 1</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//以非公平锁的方式尝试加锁 nonfairTryAcquire方法的实现在父类Sync中</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sync类中的nonfairtryacquireint-acquires-方法"><a class="markdownIt-Anchor" href="#sync类中的nonfairtryacquireint-acquires-方法">#</a>  <code>Sync</code>  类中的 <code>nonfairTryAcquire(int acquires)</code>  方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> * 非公平锁方式尝试获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取state，如果C！=0，代表有线程获取了锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">//如果没有线程获取了锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//使用CAS操作加锁（插队）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//加锁成功，设置持有锁的线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">//返回true，获取锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有线程获取了锁，并且是当前线程持有锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">//在state基础上继续增加值 （锁重入）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            <span class="comment">//更新state值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果前面的操作都失败，则加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="添加到同步队列"><a class="markdownIt-Anchor" href="#添加到同步队列">#</a> 添加到同步队列</h4>
<p>当获取锁失败后添加到阻塞队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 添加节点到队尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="comment">//以独占模式添加新Node</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//将当前节点添加到队尾</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//设置队尾为当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果设置尾节点失败 ，使用enq方法设置当前节点为尾节点，enq方法内部有个死循环 ，总会成功设置当前节点为队尾并且返回</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment"> * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * addWaiter方法运行完毕后就会运行本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//注意这里是一个死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前节点的前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前一个节点是head节点，head节点为占有锁的线程，说明当前线程是距离获得锁最近的线程，尝试获取锁（公平锁和非公平锁的区别就在于tryAcquire）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//如果获取锁成功，那么将头节点设置为自己</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入到这里时说明锁已经被其他线程占用，判断是否需要挂起线程，如果需要挂起返回true</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            <span class="comment">//挂起线程  等待唤醒</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：简单的说就是先尝试获取锁，如果获取锁失败，那么就将线程加入队列，加入队列后如果是在 head 节点之后的第一个节点，那么再次尝试获取锁，如果没有在 head 节点后，那么判断是否应该将线程挂起，如果线程被挂起，那么就需要等待前驱唤醒（前驱释放锁之后会唤醒后继节点）。</p>
</blockquote>
<h4 id="公平锁实现fairsync"><a class="markdownIt-Anchor" href="#公平锁实现fairsync">#</a> 公平锁实现 <code>FairSync</code></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"><span class="comment">//加锁 和上面的 NonfairSync 的区别在于少了插队操作</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//以独占锁的方式加锁 acquire()方法会调用tryAcquire()方法</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试加锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取state，c！=0 代表有线程持有锁，如果没有线程持有锁则为0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//查看阻塞队列中是否有线程在排队等待获取锁，如果有其他线程在当前线程前面，则返回true，否则返回false</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">//如果当前线程前面没有其他线程排队，则使用CAS修改state变量，尝试加锁</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功，设置持有锁的线程为当前线程</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果state不等于0 判断持有锁的线程是否是当前线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//如果是当前线程，在state基础上加对应的值 （锁重入）</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="comment">//如果小于0，报错，state最小为0</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">//更新state值</span></span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果前面的操作都没有成功，则尝试加锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="解锁"><a class="markdownIt-Anchor" href="#解锁">#</a> 解锁</h4>
<p>根据前面内容知道了如果线程获取锁失败，会进入挂起状态，然后等待前驱节点的唤醒。前驱节点释放锁之后就会唤醒后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用解锁方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//如果释放锁成功</span></span><br><span class="line">        <span class="comment">//获取占有锁的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to set the state to reflect a release in exclusive</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is always invoked by the thread performing release.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation throws</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is always the one</span></span><br><span class="line"><span class="comment"> *        passed to a release method, or the current state value upon</span></span><br><span class="line"><span class="comment"> *        entry to a condition wait.  The value is otherwise</span></span><br><span class="line"><span class="comment"> *        uninterpreted and can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this object is now in a fully released</span></span><br><span class="line"><span class="comment"> *         state, so that any waiting threads may attempt to acquire;</span></span><br><span class="line"><span class="comment"> *         and &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalMonitorStateException if releasing would place this</span></span><br><span class="line"><span class="comment"> *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment"> *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment"> *         correctly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedOperationException if exclusive mode is not supported</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">//获取释放后的state状态，c=0 才释放锁成功</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">//如果要释放锁的线程不是拥有锁的线程，报错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果释放后的state为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//设置占有锁的线程为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新state</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当解锁成功之后， <code>unparkSuccessor(Node node)</code>  方法会唤醒后继节点，通过前面的代码我们知道线程在 <code>parkAndCheckInterrupt()</code>  处被挂起了，当线程被唤醒后， <code>parkAndCheckInterrupt()</code>  方法会判断线程是否处于停止状态，一般情况下返回 false，所以代码会重新进入循环（外面有个死循环），重新获取锁，如果获取失败，继续挂起，或者退出线程。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java读写锁ReentrantReadWriteLock</title>
    <url>/2019/01/23/Java%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁">#</a> 读写锁</h2>
<blockquote>
<p>读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性，因为在多处理器系统中，它允许同时有多个读者来访问共享资源，最大可能的读者数为实际的逻辑 CPU 数。写者是排他性的，一个读写锁同时只能有一个写者或多个读者（与 CPU 数相关），但不能同时既有读者又有写者。<br>
如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p>
</blockquote>
<h2 id="reedtrantreadwritelock-的基本使用"><a class="markdownIt-Anchor" href="#reedtrantreadwritelock-的基本使用">#</a> ReedtrantReadWriteLock 的基本使用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RWLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//新建一个实例</span></span><br><span class="line">        <span class="type">RWLockTest</span> <span class="variable">rwLockTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RWLockTest</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                rwLockTest.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                rwLockTest.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取：num=&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = i;</span><br><span class="line">            System.out.println(<span class="string">&quot;写入&quot;</span> + i + <span class="string">&quot;:num=&quot;</span> + num);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reedtrantreadwritelock-解析"><a class="markdownIt-Anchor" href="#reedtrantreadwritelock-解析">#</a> ReedtrantReadWriteLock 解析</h2>
<p>ReedtrantReadWriteLock 变量和构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 读锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">/** 写锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认为非公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair 如果为true则为公平锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="comment">//设置为公平锁或者非公平锁</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的构造方法可以看出 ReedtrantReadWriteLock 拥有两个锁，一个写锁（排它锁），一个读锁（共享锁）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回写锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="comment">//返回读锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="title function_">readLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure>
<p>lock () 方法或者 unlock () 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里只列出了主要的两个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，保存Sync</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//写锁加锁 独占锁  在AQS中被实现</span></span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//写锁解锁</span></span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//读锁解锁 共享锁</span></span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//读锁解锁</span></span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以得出 ReentrantReadWriteLock 有两个锁，读锁和写锁，而读锁和写锁都是通过 Sync 来进行加锁，不同的点在于调用 Sync 的方法不同</p>
<p>Sync：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//******************************************************************************************</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="comment">//最大锁数量  65535 2的16次方减一</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二进制值为  0000 0000 0000 0000 1111 1111 1111 1111</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 返回共享锁的数量  也就是读锁 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** 返回排它锁的数量  也就是写锁  */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            对于上面的这段代码，同学们可能不是很清楚</span></span><br><span class="line"><span class="comment">            我们知道AQS只有一个变量state代表锁状态，但是读锁和写锁有两个锁，如何表示两个锁呢？</span></span><br><span class="line"><span class="comment">            首先state是int型 32位，这里将state的高16位作为读锁，低16位作为读锁</span></span><br><span class="line"><span class="comment">            再看看 c &gt;&gt;&gt; SHARED_SHIFT 将state无符号右移16位，是不是就只剩下高位16位，也就是读锁的数量。</span></span><br><span class="line"><span class="comment">            然后  c &amp; EXCLUSIVE_MASK 我们知道EXCLUSIVE_MASK的值为16个1，前面16位都是0，然后进行按位与计算，</span></span><br><span class="line"><span class="comment">            最后的结果就是低16位的值，也就是写锁的数量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//用于记录当前线程的读锁持有数量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">        <span class="comment">//缓存最后一个获取读锁的线程的读锁重入次数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">        <span class="comment">//第一个获取读锁的线程，必须持有读锁，释放之后就不算第一个了。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//第一个获取读锁的线程的锁重入数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;</span><br><span class="line">    <span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------写锁加锁与解锁-----------------------</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="comment">//获取锁整体状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//求出写锁状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="comment">//如果state不等于0</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果整体状态 c 不等于0，并且写锁 w 为0，那么读锁一定不为 0</span></span><br><span class="line">                <span class="comment">//所以在w==0或者写锁占有者不是当前线程都加锁失败</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">//在读锁存在或者有其他写锁占有的情况下，写锁加锁失败</span></span><br><span class="line">                <span class="comment">//返回false 进入阻塞队列，如果忘了 请回顾上一章内容</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//走到这一步说明没有读锁，并且持有写锁的线程为自己</span></span><br><span class="line">                <span class="comment">//如果继续为当前线程加锁（锁重入），加锁数大于了最大值65535 报错</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// 更新锁状态</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//走到这一步的时候 说明c==0 没有读锁 也没有写锁</span></span><br><span class="line">            <span class="comment">//根据是否是公平锁来选择是否优先为写锁加锁</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            <span class="comment">//尝试CAS获取锁 （插队）</span></span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//如果写锁加锁成功，设置持有锁的线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁释放 在AQS中被调用</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">//如果释放锁的线程不是持有锁的线程 报错</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">                <span class="comment">//获取锁整体状态并减去对应的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="comment">//如果最后的写锁状态为0，说明锁已经释放</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">            <span class="comment">//设置锁持有者为null</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//更新state</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//----------------------写锁加锁与解锁结束----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------读锁加锁与解锁----------------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    由读锁加锁时调用</span></span><br><span class="line"><span class="comment">    acquireShared方法在AQS中的实现</span></span><br><span class="line"><span class="comment">    public final void acquireShared(int arg) &#123;</span></span><br><span class="line"><span class="comment">        if (tryAcquireShared(arg) &lt; 0)</span></span><br><span class="line"><span class="comment">            doAcquireShared(arg);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁整体状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//如果写锁存在并且持有写锁的线程不是当前线程，直接返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">//返回 -1 即失败</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//获取读锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">            <span class="comment">//判断读线程是否应该阻塞（可以自己下来了解该方法，这里不做讲解）</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                <span class="comment">//如果读线程不应该阻塞，尝试加上读锁</span></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="comment">//如果读线程为0，说明之前没有其他读线程</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//如果读线程为获取读锁的第一个线程，读锁重入数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//最后一个获取读锁的线程</span></span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="comment">//如果最后一个获取读锁的线程不是当前线程 ，设置缓存为当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读锁加锁失败调用接下来的方法自旋获取读锁</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取锁整体状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//如果写锁被占用</span></span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//写锁的持有线程不是当前线程</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="comment">//返回 -1  </span></span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//判断读锁是否应该被阻塞，公平锁与非公平锁锁有不同的实现</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读锁数量达到最大值  报错</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">//CAS设置读锁</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="comment">//接下来的代码基本和前面的代码差不多，不再说明了</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//如果当前线程为第一个获取了读锁的线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="comment">//如果锁获取数量为1 则将firstReader置为null 否则将锁的持有数量减一</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//更新当前线程读锁的持有数量</span></span><br><span class="line">                <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//减少读锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">                <span class="comment">//CAS更新</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// 如果读锁全部释放（也就是0） 返回true</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//----------------------------读锁加锁与解锁解锁----------------------------</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁降级"><a class="markdownIt-Anchor" href="#锁降级">#</a> 锁降级</h2>
<p>官方示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">   Object data;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid; <span class="comment">//用于检测数据是否已经修改过了，如果被修改过了，就不许修改了 </span></span><br><span class="line">   <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">     rwl.readLock().lock();<span class="comment">//@1</span></span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">        <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">        rwl.readLock().unlock();<span class="comment">//@4</span></span><br><span class="line">        rwl.writeLock().lock();<span class="comment">//@2</span></span><br><span class="line">        <span class="comment">// Recheck state because another thread might have acquired</span></span><br><span class="line">        <span class="comment">//   write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;<span class="comment">//@3</span></span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     use(data);</span><br><span class="line">     rwl.readLock().unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>锁降级主要是为了保证在使用时，保证数据没有被其他线程重写，能获取到最新的数据。主要操作就是在写锁没有释放之前获取读锁。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty实现心跳处理</title>
    <url>/2020/10/06/Netty%E5%AE%9E%E7%8E%B0%E5%BF%83%E8%B7%B3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在 Socket 通信中为了保证 Server 和 Client 连接的有效，一般会使用心跳来检测 Server 和 Client 通信是否畅通.</p>
<h2 id="server"><a class="markdownIt-Anchor" href="#server">#</a> Server</h2>
<ol>
<li>心跳处理 handler</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.whymesay.toy.monarch.transport.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.whymesay.toy.monarch.common.domain.Message;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 心跳处理 每个客户端连接的channel 都有一个handler实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> whymesay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/3 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">timeoutCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Message msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        timeoutCount.set(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg.getType() == Message.PING) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;receive client heartbeat&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(Message.PONG_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="comment">// 如果是心跳消息 超过时间客户端没有连接 下线</span></span><br><span class="line">            handlerHeartbeatTimeout(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler heartbeat timeout</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ctx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerHeartbeatTimeout</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// todo 处理</span></span><br><span class="line">        <span class="keyword">if</span> (timeoutCount.getAndIncrement() &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            ctx.close();</span><br><span class="line">            log.warn(<span class="string">&quot;monarch timeout count more than 5,close!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;monarch timeout, count: &#123;&#125;&quot;</span>, timeoutCount.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>注册 Server Handler, 配置 IdleStateHandler</li>
</ol>
<p>服务端需要添加 IdleStateHandler, 并且配置读取超时时间，超过时间没有获取到客户端的消息，触发 event</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多余的代码省略,具体代码可以查看底部的github地址</span></span><br><span class="line">       socketChannel.pipeline()</span><br><span class="line">               <span class="comment">// when idle , send  heartbeat</span></span><br><span class="line">               .addLast(<span class="string">&quot;IdleStateHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(MonarchConstant.HEART_BEAT_TIME_OUT * MonarchConstant.HEART_BEAT_TIME_OUT_MAX_TIME, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">               <span class="comment">// byte to message</span></span><br><span class="line">               .addLast(<span class="string">&quot;MonarchDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchDecoder</span>(globalConfig.getSerializeConfig()))</span><br><span class="line">               <span class="comment">// message to byte</span></span><br><span class="line">               .addLast(<span class="string">&quot;MonarchEncoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchEncoder</span>(globalConfig.getSerializeConfig()))</span><br><span class="line">               <span class="comment">// heartbeat</span></span><br><span class="line">               .addLast(<span class="string">&quot;HeartbeatServerHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">HeartbeatServerHandler</span>())</span><br><span class="line">               .addLast(<span class="string">&quot;MonarchServerHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchServerHandler</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="client"><a class="markdownIt-Anchor" href="#client">#</a> client</h2>
<ol>
<li>Client Handler</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.whymesay.toy.monarch.transport.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.whymesay.toy.monarch.common.domain.Message;</span><br><span class="line"><span class="keyword">import</span> com.github.whymesay.toy.monarch.transport.monarch.constant.MonarchConstant;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.IdleStateEvent;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 心跳处理 每个客户端连接的channel 都有一个handler实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> whymesay </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/3 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeartbeatClientHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">timeoutCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Message msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        timeoutCount.set(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg.getType() == Message.PONG) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;receive server heartbeat&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="comment">// 如果是心跳消息 超过时间客户端没有请求服务端</span></span><br><span class="line">            handlerHeartbeatTimeout(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler heartbeat timeout</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ctx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlerHeartbeatTimeout</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeoutCount.getAndIncrement() &gt;= MonarchConstant.HEART_BEAT_TIME_OUT_MAX_TIME) &#123;</span><br><span class="line">            <span class="comment">//todo 当前连接以及断开 尝试重连</span></span><br><span class="line">            ctx.close();</span><br><span class="line">            log.warn(<span class="string">&quot;monarch timeout count more than &#123;&#125;,close!&quot;</span>, MonarchConstant.HEART_BEAT_TIME_OUT_MAX_TIME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 超时未发送数据 客户端主动发送消息到server</span></span><br><span class="line">            ctx.writeAndFlush(Message.PING_MSG);</span><br><span class="line">            log.warn(<span class="string">&quot;monarch timeout, count: &#123;&#125;&quot;</span>, timeoutCount.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>注册 Client Handler, 配置 IdleStateHandler</li>
</ol>
<p>客户端和服务端基本相同，不同是我们需要配置 IdleStateHandler 的写超时，一旦没有向服务端发送消息，那么主动向服务端发起请求，说明自己还活着.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">socketChannel.pipeline()</span><br><span class="line">        .addLast(<span class="string">&quot;IdleStateHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, MonarchConstant.HEART_BEAT_TIME_OUT, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// byte to message</span></span><br><span class="line">        .addLast(<span class="string">&quot;MonarchDecoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchDecoder</span>(globalConfig.getSerializeConfig()))</span><br><span class="line">        <span class="comment">// message to byte</span></span><br><span class="line">        .addLast(<span class="string">&quot;MonarchEncoder&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchEncoder</span>(globalConfig.getSerializeConfig()))</span><br><span class="line">        .addLast(<span class="string">&quot;HeartbeatClientHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">HeartbeatClientHandler</span>())</span><br><span class="line">        .addLast(<span class="string">&quot;MonarchClientHandler&quot;</span>, <span class="keyword">new</span> <span class="title class_">MonarchClientHandler</span>(<span class="built_in">this</span>));</span><br></pre></td></tr></table></figure>
<h2 id="代码地址"><a class="markdownIt-Anchor" href="#代码地址">#</a> 代码地址</h2>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3doeW1lc2F5L3RveS1tb25hcmNoL3RyZWUvbWFzdGVyL3NyYy9tYWluL2phdmEvY29tL2dpdGh1Yi93aHltZXNheS90b3kvbW9uYXJjaC90cmFuc3BvcnQvbW9uYXJjaA==">https://github.com/whymesay/toy-monarch/tree/master/src/main/java/com/github/whymesay/toy/monarch/transport/monarch</span></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中使用logback日志框架</title>
    <url>/2021/03/06/SpringBoot%E4%B8%AD%E4%BD%BF%E7%94%A8logback%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h2>
<p>SpringBoot 默认的日志框架就是 logback, 所以使用的时候直接使用就可以了，不需要添加其他依赖，所以这里记录几个关于配置的小问题.</p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置">#</a> 配置</h2>
<p>1. 首先在 resources 目录下建立文件 logback-spring.xml, 添加下面的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--这里读取的是application.properties中的logging.pattern.console --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.demo&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里有个问题就是level会优先取application.properties中的logging.level.root属性,所以如果按照下面的application.properties中的配置,这里的日志级别实际上是DEBUG--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2. 在 application.properties 中添加以下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.config</span>=<span class="string">classpath:logback-spring.xml</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=<span class="string">[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] -- [%-5p]: [%c] -- %m%n</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>个人学习笔记</title>
    <url>/2021/01/17/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面">#</a> 写在前面</h1>
<p>个人的一些学习记录，一些自己看过觉得不错，并且希望在之后回顾的时候能够快速的找到链接.</p>
<span id="more"></span>
<h2 id="java"><a class="markdownIt-Anchor" href="#java">#</a> JAVA</h2>
<h3 id="基础"><a class="markdownIt-Anchor" href="#基础">#</a> 基础</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVsaW5mZW5nL3AvNjYwMjkwMi5odG1s">&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; 移位操作</span></p>
<h3 id="系统设计"><a class="markdownIt-Anchor" href="#系统设计">#</a> 系统设计</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hcGxlX3Nvbi9hcnRpY2xlL2RldGFpbHMvMTA1MDI2NzQ3">一篇，快速搞懂各种重试策略</span></p>
<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池">#</a> 线程池</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZG9vcC5jb20vcG9zdC9qYXZhLXRocmVhZC1wb29s">深度解读 Java 线程池设计思想及源码实现</span><br>
<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMDQvMDIvamF2YS1wb29saW5nLXByYXRpY2UtaW4tbWVpdHVhbi5odG1s"> Java 线程池实现原理及其在美团业务中的实践</span></p>
<h3 id="jvm"><a class="markdownIt-Anchor" href="#jvm">#</a> JVM</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTEvMTIvamF2YS05LWNtcy1nYy5odG1s">Java 中 9 种常见的 CMS GC 问题分析与解决</span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS93ZWJmb2xkZXIvdGVjaG5ldHdvcmsvdHV0b3JpYWxzL29iZS9qYXZhL2djMDEvaW5kZXguaHRtbA=="> Java Garbage Collection Basics</span><br>
<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMTgyMDU3Nw=="> 面试官：你说你熟悉 jvm? 那你讲一下并发的可达性分析</span></p>
<h3 id="spring"><a class="markdownIt-Anchor" href="#spring">#</a> Spring</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvY2ltZE1tYndmeU5CRmtUekd1UEdlQQ==">面试题：Spring 为何需要三级缓存解决循环依赖，而不是二级缓存？</span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ3JleS13b2xmL3AvMTMwMzQzNzEuaHRtbA==">曹工说 Spring Boot 源码（29）-- Spring 解决循环依赖为什么使用三级缓存，而不是二级缓存</span></p>
<h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库">#</a> 数据库</h2>
<h3 id="mysql"><a class="markdownIt-Anchor" href="#mysql">#</a> MySql</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTQvMDgvMjAvaW5ub2RiLWxvY2suaHRtbA==">Innodb 中的事务隔离级别和锁的关系</span><br>
<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTYvMTEvMTgvZGlhbnBpbmctb3JkZXItZGItc2hhcmRpbmcuaHRtbA==">大众点评订单系统分库分表实践</span><br>
<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzOTQ0MTg4MDY3ODQ4">重学 MySQL 系列 (一)：谈谈 MySQL 架构</span></p>
<h3 id="redis"><a class="markdownIt-Anchor" href="#redis">#</a> Redis</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzODc0OTI3NTI1OTAy">10 分钟彻底理解 Redis 的持久化机制：RDB 和 AOF</span></p>
<h2 id="中间件"><a class="markdownIt-Anchor" href="#中间件">#</a> 中间件</h2>
<h3 id="rocketmq"><a class="markdownIt-Anchor" href="#rocketmq">#</a> RocketMQ</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MDA4NjI5MzU0NTA0">《浅入浅出》-RocketMQ</span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHptYXJrL3Avcm9ja2V0X3R4bi5odG1s">RocketMQ 事务消息实现分析</span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaHptYXJrL3AvbXEtZGVsYXktbXNnLmh0bWw=">如何在 MQ 中实现支持任意延迟的消息？</span><br>
<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAyMzg1NDk1MA==">消息队列之推还是拉，RocketMQ 和 Kafka 是如何做的？</span></p>
<h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统">#</a> 操作系统</h2>
<h3 id="linux"><a class="markdownIt-Anchor" href="#linux">#</a> Linux</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTE3MDk2ODE2MTE4ODU3NzM2">6w 字搞定 Linux 基本操作，建议收藏</span></p>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他">#</a> 其他</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvNk5oOWl1ZmozMVVBazJ4Y3N0TTRxdw==">深入剖析配置中心的长轮询机制</span></p>
<h2 id="技术博客"><a class="markdownIt-Anchor" href="#技术博客">#</a> 技术博客</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLw==">美团技术团队</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qYXZhZG9vcC5jb20v">Javadoop</span></li>
</ul>
<h1 id="最后"><a class="markdownIt-Anchor" href="#最后">#</a> 最后</h1>
<p>资源来自互联网收集，侵删.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>待看文章列表</title>
    <url>/2021/02/10/%E5%BE%85%E7%9C%8B%E6%96%87%E7%AB%A0%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="待看文章"><a class="markdownIt-Anchor" href="#待看文章">#</a> 待看文章</h2>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTI1MjE3NDk4NzIzNzc4NTY4">全网最硬核 JVM TLAB 分析</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTM2MzkwNDk2MTIyMDQ0NDIz">《不看后悔》38 个 JVM 精选问答，让你变成专家！</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTc5OTc3">Linux 6 种日志查看方法，不会看日志会被鄙视的</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTU1ODQxNzQxMzQ5OTc4MTQz">Tomcat 中是怎么处理文件上传的？</span></li>
</ol>
<h2 id="待解决问题"><a class="markdownIt-Anchor" href="#待解决问题">#</a> 待解决问题</h2>
<ol>
<li>Spring 循环依赖解决方案</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Learn</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-大数相乘(字符串相乘)</title>
    <url>/2019/03/06/%E7%AE%97%E6%B3%95-%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h2>
<blockquote>
<p>给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。</p>
<p>注意：</p>
<p>num1 和 num2 的长度都小于 5100.<br>
num1 和 num2 都只包含数字 0-9.<br>
num1 和 num2 都不包含任何前导零。<br>
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p>
<p>来源：力扣（LeetCode）<br>
链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXN0cmluZ3M=">https://leetcode-cn.com/problems/add-strings</span><br>
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解决方法-竖式运算"><a class="markdownIt-Anchor" href="#解决方法-竖式运算">#</a> 解决方法 - 竖式运算</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (res[i + j + <span class="number">1</span>] + n1 * n2);</span><br><span class="line">                <span class="comment">//进位处理</span></span><br><span class="line">                res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//求出当前位的值</span></span><br><span class="line">                res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            result.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者：breezean<br>
 链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbXVsdGlwbHktc3RyaW5ncy9zb2x1dGlvbi95b3UtaHVhLWJhbi1zaHUtc2hpLWRhLWJhaS05OTQtYnktYnJlZXplYW4v">https://leetcode-cn.com/problems/multiply-strings/solution/you-hua-ban-shu-shi-da-bai-994-by-breezean/</span><br>
 来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ul>
<li>时间复杂度:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="解决方法-karatsuba乘法"><a class="markdownIt-Anchor" href="#解决方法-karatsuba乘法">#</a> 解决方法 - Karatsuba 乘法</h2>
<p><img data-src="/img/posts/Karatsuba.png" alt="karatsuba"></p>
<br>
<p>最后的结果就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext>∗</mtext><mi>y</mi><mo>=</mo><mi>a</mi><mtext>∗</mtext><mi>c</mi><mtext>∗</mtext><mn>1</mn><msup><mn>0</mn><mi>n</mi></msup><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mtext>∗</mtext><mi>d</mi><mo>+</mo><mi>b</mi><mtext>∗</mtext><mi>c</mi><mo stretchy="false">)</mo><mtext>∗</mtext><mn>1</mn><msup><mn>0</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><mi>b</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">x∗y=a∗c∗10^n+(a ∗ d + b ∗ c)∗10^{n/2}+bd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class="mord">∗</span><span class="mord mathnormal">c</span><span class="mord">∗</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord">∗</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord">∗</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord">∗</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">d</span></span></span></span></p>
<p>比如 12345*6789, 那么 a=12,b=345,c=6,d=789</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Karatsuba乘法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">karatsuba</span><span class="params">(<span class="type">long</span> num1, <span class="type">long</span> num2)</span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(num1 &lt; <span class="number">10</span> || num2 &lt; <span class="number">10</span>) <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    <span class="comment">// 计算拆分长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size1</span> <span class="operator">=</span> String.valueOf(num1).length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">size2</span> <span class="operator">=</span> String.valueOf(num2).length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">halfN</span> <span class="operator">=</span> Math.max(size1, size2) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 拆分为a, b, c, d */</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> Long.valueOf(String.valueOf(num1).substring(<span class="number">0</span>, size1 - halfN));</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> Long.valueOf(String.valueOf(num1).substring(size1 - halfN));</span><br><span class="line">    <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> Long.valueOf(String.valueOf(num2).substring(<span class="number">0</span>, size2 - halfN));</span><br><span class="line">    <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> Long.valueOf(String.valueOf(num2).substring(size2 - halfN));</span><br><span class="line">    <span class="comment">// 计算z2, z0, z1, 此处的乘法使用递归</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">z2</span> <span class="operator">=</span> karatsuba(a, c);</span><br><span class="line">    <span class="type">long</span> <span class="variable">z0</span> <span class="operator">=</span> karatsuba(b, d);</span><br><span class="line">    <span class="type">long</span> <span class="variable">z1</span> <span class="operator">=</span> karatsuba((a + b), (c + d)) - z0 - z2;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)(z2 * Math.pow(<span class="number">10</span>, (<span class="number">2</span>*halfN)) + z1 * Math.pow(<span class="number">10</span>, halfN) + z0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度:$ O (n^{log_2 3}) $</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
